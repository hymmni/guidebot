<!doctype html>
<html lang="ko">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TourBot</title>
  <link rel="stylesheet" href="styles.css">
  <script src="https://cdn.jsdelivr.net/npm/webaudio-recorder-js/lib-webaudio-recorder-js.min.js"></script>
</head>

<body>
  <div class="wrap">
    <aside>
      <button class="navbtn">지도</button>
      <button class="navbtn">정보</button>
      <button class="navbtn">호출</button>
      <button class="lang">언어</button>
    </aside>

    <main>
      <div id="convPanel">
        <section id="faceStage">
          <button id="faceBtn" aria-label="얼굴 클릭">
            <div class="eyes">
              <div class="eye">
                <div class="pupil"></div>
              </div>
              <div class="eye">
                <div class="pupil"></div>
              </div>
            </div>
            <div class="mouth"></div>
          </button>
          <div class="hint">“에스뽀!” 라고 불러주세요</div>
        </section>

        <section id="chatStage">
          <div id="messages" class="messages"></div>
          <audio id="player"></audio>
        </section>
      </div>

      <section id="infoPanel">어쩌구저쩌구</section>
    </main>
  </div>

  <script>
    'use strict';

    /* =========================
     * 기본 환경
     * ========================= */
    const BASE = location.origin;
    const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://") + location.host + "/ws/kiosk";

    const body = document.body;
    const faceBtn = document.getElementById('faceBtn');
    const messages = document.getElementById('messages');
    const player = document.getElementById('player');
    const infoPanel = document.getElementById('infoPanel');

    /* =========================
     * 메시지 UI
     * ========================= */
    function displayBotResponse(text) {
      const el = document.createElement('div');
      el.className = 'message bBubble bot-bubble';
      el.textContent = text;
      messages.appendChild(el);
      setTimeout(() => {
        el.classList.add('show');
        el.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }
    function displayUserMessage(text) {
      const el = document.createElement('div');
      el.className = 'message uBubble user-bubble';
      el.textContent = text;
      messages.appendChild(el);
      setTimeout(() => {
        el.classList.add('show');
        el.scrollIntoView({ behavior: 'smooth', block: 'end' });
      }, 100);
    }

    /* =========================
     * 지도 표시
     * ========================= */
    function showMap(url) {
      infoPanel.innerHTML = `<img id="mapImg" src="${url}" alt="지도" style="max-width:100%;height:auto;display:block;margin:8px auto;" />`;
    }

    /* =========================
     * VAD 파라미터
     * ========================= */
    const VAD = {
      rmsStart: 0.020,   // 시작 임계
      rmsStop: 0.010,   // 종료 임계
      startHoldMs: 120,
      stopHoldMs: 800,
      maxRecordMs: 15000,
      debug: false
    };

    /* =========================
     * 오디오/녹음 상태
     * ========================= */
    let mediaRecorder = null;
    let audioStream = null;
    let audioCtx = null, analyser = null, srcNode = null, rafId = 0;
    let isRecording = false, recordStartTs = 0;
    let lastTick = 0, voiceMs = 0, silenceMs = 0;
    const vadBuf = new Float32Array(2048); // analyser.fftSize와 동일

    /* =========================
     * VAD 기반 녹음 → 업로드
     * ========================= */
    async function recordAndSend() {
      try {
        // 웨이크워드 리스너와 마이크 충돌 방지
        stopWakeWord();

        // 1) 마이크 스트림
        audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // 2) 분석용 AudioContext/Analyser
        audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        srcNode = audioCtx.createMediaStreamSource(audioStream);
        analyser = audioCtx.createAnalyser();
        analyser.fftSize = 2048;
        analyser.smoothingTimeConstant = 0.2;
        srcNode.connect(analyser);

        // 3) 모니터 루프 시작
        resetVAD();
        tick();
        console.log("VAD 대기 시작(말하면 자동 녹음).");
      } catch (err) {
        console.error("녹음 시작 실패:", err);
        alert("마이크 권한을 허용해야 합니다. (HTTPS 또는 localhost 필요)");
      }
    }

    function resetVAD() {
      isRecording = false;
      voiceMs = 0;
      silenceMs = 0;
      lastTick = 0;
    }

    function tick(ts = 0) {
      if (!analyser) return;

      if (lastTick === 0) lastTick = ts;
      const dt = ts - lastTick;
      lastTick = ts;

      analyser.getFloatTimeDomainData(vadBuf);
      let sum = 0;
      for (let i = 0; i < vadBuf.length; i++) {
        const v = vadBuf[i];
        sum += v * v;
      }
      const rms = Math.sqrt(sum / vadBuf.length);

      if (VAD.debug) console.log("RMS:", rms.toFixed(4));

      if (!isRecording) {
        if (rms >= VAD.rmsStart) {
          voiceMs += dt;
          if (voiceMs >= VAD.startHoldMs) startRecording();
        } else {
          voiceMs = 0;
        }
      } else {
        if (rms < VAD.rmsStop) silenceMs += dt;
        else silenceMs = 0;

        const elapsed = performance.now() - recordStartTs;
        if (silenceMs >= VAD.stopHoldMs || elapsed >= VAD.maxRecordMs) {
          stopRecording(); // onstop에서 업로드
          return;
        }
      }

      rafId = requestAnimationFrame(tick);
    }

    function chooseMime() {
      const candidates = [
        'audio/webm;codecs=opus',
        'audio/webm',
        'audio/ogg;codecs=opus',
        'audio/ogg'
      ];
      for (const c of candidates) {
        if (MediaRecorder.isTypeSupported?.(c)) return c;
      }
      return ''; // 브라우저 기본
    }

    function startRecording() {
      if (!audioStream) return;

      const mimeType = chooseMime(); // onstop에서 전역 참조 대신 로컬 캡처
      mediaRecorder = new MediaRecorder(audioStream, mimeType ? { mimeType } : {});
      const chunks = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) chunks.push(e.data);
      };

      mediaRecorder.onstop = async (e) => {
        cancelAnimationFrame(rafId);
        rafId = 0;
        teardownNodes();

        // 전역 mediaRecorder 대신 안전한 참조 사용
        const rec = e?.target || mediaRecorder || null;
        const blobType =
          mimeType ||
          (rec && rec.mimeType) ||
          'audio/webm';

        const blob = new Blob(chunks, { type: blobType });
        if (!blob || blob.size === 0) {
          console.log("무음/장치 문제로 0바이트. 재대기 진입.");
          setTimeout(() => { if (body.classList.contains('chat-open')) recordAndSend(); }, 300);
          teardownStream();
          return;
        }

        try {
          const fd = new FormData();
          fd.append("file", blob, "speech.webm");
          const up = await fetch(`${BASE}/upload-audio/`, { method: "POST", body: fd });
          if (!up.ok) { console.error("업로드 실패:", up.status); return; }
          const { file_id } = await up.json();

          // WS 상태와 무관하게 안전 전송
          sendJson({ file_id });
        } catch (err) {
          console.error("업로드 오류:", err);
        } finally {
          teardownStream();
        }
      };

      mediaRecorder.start();
      isRecording = true;
      recordStartTs = performance.now();
      voiceMs = 0;
      console.log("녹음 시작 (VAD).");
    }

    function stopRecording() {
      if (mediaRecorder && mediaRecorder.state === "recording") {
        mediaRecorder.stop();
        console.log("녹음 종료 (VAD).");
      }
    }

    // 채팅 닫을 때 전체 정리
    function teardownAudio() {
      try { stopRecording(); } catch { }
      cancelAnimationFrame(rafId);
      rafId = 0;
      teardownNodes();
      teardownStream();
    }

    function teardownNodes() {
      try { srcNode && srcNode.disconnect(); } catch { }
      try { analyser && analyser.disconnect(); } catch { }
      srcNode = null;
      analyser = null;
      if (audioCtx) {
        audioCtx.close().catch(() => { });
        audioCtx = null;
      }
    }

    function teardownStream() {
      if (audioStream) {
        try { audioStream.getTracks().forEach(t => t.stop()); } catch { }
        audioStream = null;
      }
      mediaRecorder = null;
      isRecording = false;

      // 채팅이 닫혀 있으면 웨이크 다시 켜기
      if (!document.body.classList.contains('chat-open')) startWakeWord();
    }

    /* =========================
     * WebSocket (끊김 방지)
     * ========================= */
    let ws = null;
    let wsRetry = 0;
    let wsTimer = null;
    let hbTimer = null;
    let lastActivity = Date.now();
    const outbox = []; // 연결 끊긴 동안 보낼 메시지

    const HEARTBEAT_MS = 25_000;
    const STALL_MS = 65_000;
    const MAX_BACKOFF = 15_000;

    function stopHeartbeat() {
      if (hbTimer) { clearInterval(hbTimer); hbTimer = null; }
    }
    function startHeartbeat() {
      stopHeartbeat();
      hbTimer = setInterval(() => {
        if (!ws) return;
        if (ws.readyState === WebSocket.OPEN) {
          try { ws.send(JSON.stringify({ type: 'ping' })); lastActivity = Date.now(); } catch { }
        }
        if (Date.now() - lastActivity > STALL_MS) {
          console.warn("[WS] Stall detected → forcing reconnect");
          scheduleReconnect(true);
        }
      }, HEARTBEAT_MS);
    }
    function tearDownSocket() {
      if (!ws) return;
      try { ws.onopen = ws.onmessage = ws.onclose = ws.onerror = null; ws.close(1000, 'reinit'); } catch { }
      ws = null; stopHeartbeat();
    }
    function scheduleReconnect(immediate = false) {
      if (wsTimer) return;
      const delay = immediate ? 0 : Math.min(1000 * Math.pow(2, wsRetry++), MAX_BACKOFF);
      wsTimer = setTimeout(() => { wsTimer = null; initWebSocket(); }, delay);
      console.log(immediate ? "[WS] Reconnect now" : `[WS] Reconnect in ${Math.round(delay / 1000)}s`);
    }
    function flushOutbox() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      while (outbox.length) {
        const msg = outbox.shift();
        try { ws.send(JSON.stringify(msg)); } catch (e) { outbox.unshift(msg); break; }
      }
    }
    function sendJson(obj) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        try { ws.send(JSON.stringify(obj)); } catch (e) { outbox.push(obj); }
      } else {
        outbox.push(obj);
      }
    }
    function initWebSocket() {
      tearDownSocket();
      try {
        ws = new WebSocket(WS_URL);
      } catch (e) {
        console.error("[WS] 생성 실패:", e);
        scheduleReconnect();
        return;
      }

      ws.onopen = () => {
        console.log("WebSocket 연결 성공");
        wsRetry = 0;
        lastActivity = Date.now();
        startHeartbeat();
        flushOutbox();
      };

      ws.onmessage = (e) => {
        lastActivity = Date.now();
        let msg;
        try { msg = JSON.parse(e.data); } catch { return; }

        if (msg.stage === "stt" && msg.text) displayUserMessage(msg.text);
        if (msg.stage === "llm" && msg.text) displayBotResponse(msg.text);
        if (msg.stage === "tts" && msg.audio_url) {
          player.src = msg.audio_url;
          player.playbackRate = 1.5;
          player.play().catch(() => { });
        }
        if (msg.stage === "ui" && msg.type === "show_map" && msg.url) {
          showMap(msg.url);
        }
      };

      ws.onclose = (ev) => {
        console.log("WebSocket 연결 종료:", ev.code, ev.reason || "");
        stopHeartbeat();
        scheduleReconnect();
      };

      ws.onerror = (err) => {
        console.warn("WebSocket 오류:", err);
        try { ws.close(); } catch { }
        // onclose에서 재연결
      };
    }
    window.addEventListener('online', () => scheduleReconnect(true));
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible' && (!ws || ws.readyState !== WebSocket.OPEN)) {
        scheduleReconnect(true);
      }
    });

    /* =========================
     * TTS
     * ========================= */
    async function playTTS(text) {
      try {
        const res = await fetch(`${BASE}/request-response`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ text, speed: 1.0 })
        });
        const { audio_url } = await res.json();
        if (audio_url) {
          player.src = audio_url;
          player.playbackRate = 1.5;
          player.play().catch(() => { });
        }
      } catch (e) {
        console.error("TTS 재생 오류:", e);
      }
    }
    player.onended = () => {
      if (body.classList.contains('chat-open')) {
        recordAndSend(); // TTS 끝나면 듣기 대기
      }
    };

    /* =========================
     * 얼굴 버튼(채팅 열고 닫기)
     * ========================= */
    faceBtn.addEventListener("click", () => {
      const isChatOpen = body.classList.contains('chat-open');
      body.classList.toggle('chat-open');

      if (!isChatOpen) {
        // 채팅 열기 → 웨이크 중지(충돌 방지)
        stopWakeWord();

        messages.innerHTML = "";
        displayBotResponse("무엇을 도와드릴까요?");
        playTTS("무엇을 도와드릴까요?"); // onended → recordAndSend()
      } else {
        teardownAudio(); // 채팅 닫기
        startWakeWord(); // 다시 웨이크 대기
      }
    });

    /* =========================
     * 웨이크워드 "에스뽀"
     * ========================= */
    let wakeRec = null;
    let wakeActive = false;
    let wakePrimed = false;
    let wakeRestartTimer = null;
    let wakeBackoff = 300; // ms, 최대 2000ms

    function supportsWake() {
      return ('webkitSpeechRecognition' in window) || ('SpeechRecognition' in window);
    }
    function norm(s) { return String(s || '').replace(/\s+/g, '').replace(/[!?,.]/g, '').toLowerCase(); }

    const WAKE_CANDS = [
      '에스뽀', '에스 뽀', '에스뽀야', '에스포', '에스 보', '에스보', '스뽀', '애스뽀',
      'sp o', 'spo', 'espo', 's-po', 'S4', 's4'
    ].map(norm);

    function isWakePhrase(t) {
      const n = norm(t);
      if (WAKE_CANDS.some(c => n.includes(c))) return true;
      if (n.includes('에스') && (n.includes('뽀') || n.includes('보') || n.includes('포'))) return true;
      return false;
    }

    function restartWake(reason = 'restart') {
      if (!wakeActive) return;
      clearTimeout(wakeRestartTimer);
      wakeRestartTimer = setTimeout(() => {
        try { wakeRec && wakeRec.start(); console.log('[Wake] restart:', reason); } catch { }
      }, wakeBackoff);
      wakeBackoff = Math.min(wakeBackoff * 2, 2000);
    }

    function startWakeWord() {
      if (!supportsWake()) { console.warn('[Wake] not supported'); return; }
      if (wakeActive) return;

      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      const SGL = window.SpeechGrammarList || window.webkitSpeechGrammarList;

      wakeRec = new SR();
      wakeRec.lang = 'ko-KR';
      wakeRec.continuous = true;
      wakeRec.interimResults = true;
      wakeRec.maxAlternatives = 1;

      // Grammar로 가중치
      if (SGL) {
        const list = new SGL();
        const grammar = '#JSGF V1.0; grammar wake; public <wake> = 에스뽀 | 에스 뽀 | 에스보 | 에스보야 | 에스포 | 스뽀 ;';
        try { list.addFromString(grammar, 1); wakeRec.grammars = list; } catch { }
      }

      // 디버그용 이벤트
      wakeRec.onaudiostart = () => console.log('[Wake] audiostart');
      wakeRec.onsoundstart = () => console.log('[Wake] soundstart');
      wakeRec.onspeechstart = () => console.log('[Wake] speechstart');
      wakeRec.onspeechend = () => console.log('[Wake] speechend');
      wakeRec.onsoundend = () => console.log('[Wake] soundend');
      wakeRec.onaudioend = () => console.log('[Wake] audioend');

      wakeRec.onresult = (e) => {
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const alt = e.results[i][0];
          const text = alt?.transcript || '';
          const conf = (alt?.confidence ?? 0).toFixed(2);
          console.log('[Wake] heard:', text, 'conf:', conf);
          if (isWakePhrase(text)) {
            wakeBackoff = 300; // 성공 시 백오프 리셋
            stopWakeWord();
            openChatByWake();
            break;
          }
        }
      };

      wakeRec.onerror = (ev) => {
        console.warn('[Wake] error:', ev.error);
        if (ev.error === 'not-allowed') { wakeActive = false; return; }
        restartWake('onerror:' + ev.error); // no-speech/audio-capture/network 등 자동 복구
      };

      wakeRec.onend = () => {
        if (wakeActive) restartWake('onend'); // 무음 시 onend만 올 수도 있음
      };

      try {
        wakeRec.start();
        wakeActive = true;
        wakeBackoff = 300;
        console.log('[Wake] listening… Say "에스뽀"');
      } catch (e) {
        console.warn('[Wake] start failed:', e);
      }
    }

    function stopWakeWord() {
      wakeActive = false;
      clearTimeout(wakeRestartTimer);
      wakeRestartTimer = null;
      try { wakeRec && wakeRec.stop(); } catch { }
      wakeRec = null;
    }

    // 최초 1회 사용자 제스처(브라우저 정책) 후 웨이크 시작
    function primeWakeOnce() {
      if (wakePrimed) return;
      wakePrimed = true;
      startWakeWord();
    }
    window.addEventListener('pointerdown', primeWakeOnce, { once: true });
    window.addEventListener('keydown', primeWakeOnce, { once: true });

    // 웨이크로 채팅 열기
    function openChatByWake() {
      if (!document.body.classList.contains('chat-open')) {
        document.body.classList.add('chat-open');
        try { messages.innerHTML = ''; } catch { }
        displayBotResponse('네, 부르셨어요? 무엇을 도와드릴까요?');
        playTTS('네, 부르셨어요? 무엇을 도와드릴까요?'); // onended → recordAndSend()
      }
    }

    /* =========================
     * 진입점
     * ========================= */
    initWebSocket(); // WS 연결
    // wake는 사용자 제스처 이후 primeWakeOnce가 켜줌
  </script>

</body>

</html>